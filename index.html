<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guitar Tuner ‚Äì Standard (EADGBE)</title>
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #141820;
      --panel-2: #0f131a;
      --text: #e6edf3;
      --muted: #9aa7b4;
      --accent: #5cc8ff;
      --good: #21c78a;
      --warn: #ffcc66;
      --bad: #ff6b6b;
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 70% -10%, #17202b 0%, var(--bg) 40%) fixed;
      color: var(--text);
      display: grid; place-items: center;
    }
    .app {
      width: min(980px, 95vw);
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      border: 1px solid #1f2631;
      border-radius: 18px;
      box-shadow: 0 20px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
      padding: 20px 22px 26px;
    }
    header { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; }
    h1 { font-size: 22px; margin: 0; letter-spacing: .4px; font-weight: 700; }
    .muted { color: var(--muted); font-size: 13px; }

    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; justify-content: flex-end; }
    button, select, input[type="range"] {
      background: #19212b; color: var(--text);
      border: 1px solid #263141; border-radius: 10px; padding: 10px 12px; font-size: 13px;
      cursor: pointer; transition: transform .05s ease, background .2s; user-select: none;
    }
    input[type="range"] { cursor: ew-resize; padding: 6px; accent-color: var(--accent); }
    button:hover { background: #1d2733; }
    button:active { transform: translateY(1px); }
    button.primary { background: #213041; border-color: #2a3b4e; }
    button.primary:hover { background: #26384d; }

    .board { margin-top: 16px; display: grid; grid-template-columns: 1.1fr 1fr; gap: 18px; }
    @media (max-width: 860px) { .board { grid-template-columns: 1fr; } }

    .gauge-card, .readout, .strings, .tips, .wave {
      background: #0e141c; border: 1px solid #1c2330; border-radius: 14px; padding: 16px; position: relative;
    }
    .gauge-wrap { display:grid; place-items:center; padding: 10px; }

    .gauge { width: 100%; max-width: 560px; aspect-ratio: 2 / 1; }
    .needle { transform-origin: 50% 100%; transition: transform 60ms linear; }

    .readout { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; align-items: center; text-align: center; }
    .readout .big { font-size: clamp(28px, 6vw, 48px); font-weight: 800; letter-spacing: .5px; }
    .readout .label { font-size: 12px; color: var(--muted); }
    .readout .value { font-size: 18px; font-weight: 600; }

    .strings { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
    .string-btn { padding: 10px 8px; text-align: center; border-radius: 10px; border: 1px solid #263141; background: #141b24; }
    .string-btn.active { outline: 2px solid var(--accent); background: #142233; }
    .string-btn .row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .string-btn .note { font-weight: 800; font-size: 18px; }
    .string-btn .freq { font-size: 12px; color: var(--muted); }
    .string-btn .tone { background:#10161f; border:1px solid #243046; border-radius:8px; padding:6px 8px; font-size:12px; }
    .string-btn .tone.on { background:#1b2636; }

    .status-badge { position:absolute; top:12px; right:12px; font-size:12px; padding:6px 9px; border-radius: 999px; border:1px solid #233047; color: var(--muted); }
    .status-badge.ok { color:#0d2; border-color:#1d3; background:#112218; }
    .status-badge.err { color:#f77; border-color:#533; background:#2a1111; }

    .tips { font-size: 14px; color: var(--muted); line-height: 1.5; }
    .tips strong { color: var(--text); }

    .hint { text-align:center; font-size: 14px; color: var(--muted); margin-top: 6px; }

    .kv { display:flex; gap:10px; align-items:center; }
    .kv label { font-size:12px; color:var(--muted); }

    canvas { width: 100%; height: 120px; display: block; }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Guitar tuner">
    <header>
      <div>
        <h1>Guitar Tuner <span class="muted">‚Äî Standard (E A D G B E)</span></h1>
        <div class="muted">Mic pitch detection with per‚Äëstring reference tones. Green within ¬±5 cents.</div>
      </div>
      <div class="controls">
        <div class="kv"><label for="refVol">Tone vol</label><input id="refVol" type="range" min="0" max="100" value="20"/></div>
        <div class="kv"><label for="micGain">Mic boost</label><input id="micGain" type="range" min="1" max="10" step="0.5" value="3"/></div>
        <button id="micBtn" class="primary" aria-pressed="false">üéôÔ∏è Enable Microphone</button>
      </div>
    </header>

    <section class="board">
      <div class="gauge-card">
        <div id="status" class="status-badge">mic: off</div>
        <div class="gauge-wrap">
          <svg class="gauge" viewBox="0 0 200 100" aria-label="Tuning meter">
            <g id="ticks"></g>
            <circle cx="100" cy="100" r="4" fill="#8ea3b5" />
            <g id="needle" class="needle">
              <rect x="98.7" y="18" width="2.6" height="84" rx="1.3" fill="#e8f1ff" />
            </g>
            <rect x="99.2" y="10" width="1.6" height="10" rx="1" fill="#5cc8ff"/>
          </svg>
        </div>
        <div class="readout" aria-live="polite">
          <div>
            <div class="label">Detected</div>
            <div id="detectedNote" class="big">‚Äî</div>
          </div>
          <div>
            <div class="label">Frequency</div>
            <div id="freq" class="value">‚Äî Hz</div>
          </div>
          <div>
            <div class="label">Cents</div>
            <div id="cents" class="value">‚Äî</div>
          </div>
        </div>
        <div id="hint" class="hint">Grant microphone access to begin.</div>
      </div>

      <div>
        <div class="strings" role="tablist" aria-label="Strings (low to high)">
          <!-- E2 A2 D3 G3 B3 E4 -->
          <!-- buttons are populated by JS so we can attach tone toggles -->
        </div>
        <div class="tips" style="margin-top:12px">
          <p><strong>Auto mode</strong> chooses the closest string; click a tile to lock (manual). Use the speaker button to play/stop a reference tone for any string.</p>
          <p>Need more pickup? Increase <strong>Mic boost</strong> (adds gain + compression).</p>
        </div>
        <div class="wave" style="margin-top:12px">
          <div class="label" style="margin-bottom:6px">Input level</div>
          <canvas id="levelCanvas" width="800" height="140" aria-label="Waveform level visualization"></canvas>
        </div>
      </div>
    </section>
  </div>

  <script>
  // --- Constants ---
  const STANDARD = [
    { name: 'E2', freq: 82.4069 },
    { name: 'A2', freq: 110.0000 },
    { name: 'D3', freq: 146.8324 },
    { name: 'G3', freq: 196.0000 },
    { name: 'B3', freq: 246.9417 },
    { name: 'E4', freq: 329.6276 },
  ];
  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

  // UI elements
  const micBtn = document.getElementById('micBtn');
  const statusEl = document.getElementById('status');
  const freqEl = document.getElementById('freq');
  const centsEl = document.getElementById('cents');
  const detectedNoteEl = document.getElementById('detectedNote');
  const hintEl = document.getElementById('hint');
  const levelCanvas = document.getElementById('levelCanvas');
  const ticksG = document.getElementById('ticks');
  const needle = document.getElementById('needle');
  const stringsContainer = document.querySelector('.strings');
  const refVolEl = document.getElementById('refVol');
  const micGainEl = document.getElementById('micGain');

  // Mode & string selection
  let autoMode = true;
  let manualIndex = 0;

  // Audio context & nodes (input)
  let audioCtx, analyser, source, dataBuf, comp, preGain;
  let running = false;

  // Reference tone nodes
  let toneGain; // master gain for tones
  const toneOscs = new Array(STANDARD.length).fill(null);

  // Build string tiles with tone buttons
  function buildStringTiles(){
    stringsContainer.innerHTML = '';
    STANDARD.forEach((s, i)=>{
      const btn = document.createElement('button');
      btn.className = 'string-btn';
      btn.dataset.index = i;
      btn.innerHTML = `<div class="row"><div><div class="note">${s.name}</div><div class="freq">${s.freq.toFixed(2)} Hz</div></div><button type="button" class="tone" aria-pressed="false" title="Toggle reference tone">üîà</button></div>`;
      stringsContainer.appendChild(btn);
      // lock target on tile click (outside tone button)
      btn.addEventListener('click', (e)=>{
        if (e.target.closest('.tone')) return; // ignore if tone button
        setMode(false);
        manualIndex = i;
        updateActiveTile(i);
      });
      // tone toggle
      const toneBtn = btn.querySelector('.tone');
      toneBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        toggleTone(i, toneBtn);
      });
    });
    updateActiveTile(0);
  }

  function updateActiveTile(idx){
    Array.from(document.querySelectorAll('.string-btn')).forEach((b,j)=> b.classList.toggle('active', j===idx));
  }

  // Mode switching
  function setMode(isAuto){
    autoMode = isAuto;
    hintEl.textContent = isAuto ? 'Auto: closest string is selected for you.' : 'Manual: click a string tile to lock target.';
  }

  // Draw gauge ticks
  (function drawTicks(){
    const r = 90;
    for (let c=-50; c<=50; c+=10) {
      const t = (c + 50) / 100;
      const angle = Math.PI - Math.PI * t;
      const x1 = 100 + Math.cos(angle) * (r+6);
      const y1 = 100 - Math.sin(angle) * (r+6);
      const x2 = 100 + Math.cos(angle) * (r+ (c%20===0? 16:12));
      const y2 = 100 - Math.sin(angle) * (r+ (c%20===0? 16:12));
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', x1.toFixed(2));
      line.setAttribute('y1', y1.toFixed(2));
      line.setAttribute('x2', x2.toFixed(2));
      line.setAttribute('y2', y2.toFixed(2));
      line.setAttribute('stroke', c===0? '#5cc8ff' : '#415167');
      line.setAttribute('stroke-width', c%20===0? '2' : '1');
      ticksG.appendChild(line);
      if (c%20===0) {
        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        const x = 100 + Math.cos(angle) * (r+24);
        const y = 100 - Math.sin(angle) * (r+24);
        txt.setAttribute('x', x.toFixed(2));
        txt.setAttribute('y', y.toFixed(2));
        txt.setAttribute('text-anchor', 'middle');
        txt.setAttribute('dominant-baseline','middle');
        txt.setAttribute('font-size','8');
        txt.setAttribute('fill', '#8ea3b5');
        txt.textContent = (c>0? '+' : '') + c;
        ticksG.appendChild(txt);
      }
    }
  })();

  // Microphone setup with compression + adjustable gain
  micBtn.addEventListener('click', startAudio);
  async function startAudio() {
    if (running) return;
    try {
      statusEl.textContent = 'requesting mic‚Ä¶';
      const stream = await navigator.mediaDevices.getUserMedia({ audio: {
        echoCancellation: false,
        noiseSuppression: true,
        autoGainControl: true
      }});
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Input chain: mic -> compressor -> preGain -> analyser
      source = audioCtx.createMediaStreamSource(stream);
      comp = audioCtx.createDynamicsCompressor();
      comp.threshold.setValueAtTime(-50, audioCtx.currentTime);
      comp.knee.setValueAtTime(30, audioCtx.currentTime);
      comp.ratio.setValueAtTime(12, audioCtx.currentTime);
      comp.attack.setValueAtTime(0.003, audioCtx.currentTime);
      comp.release.setValueAtTime(0.25, audioCtx.currentTime);

      preGain = audioCtx.createGain();
      setMicBoost(parseFloat(micGainEl.value));

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      dataBuf = new Float32Array(analyser.fftSize);

      source.connect(comp);
      comp.connect(preGain);
      preGain.connect(analyser);

      // Reference tone chain: toneOsc -> toneGain -> destination (so you can hear it)
      toneGain = audioCtx.createGain();
      toneGain.gain.value = refVolEl.value / 100;
      toneGain.connect(audioCtx.destination);

      running = true;
      statusEl.textContent = 'mic: on';
      statusEl.classList.remove('err');
      statusEl.classList.add('ok');
      micBtn.setAttribute('aria-pressed','true');
      loop();
      drawLevel();
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'mic: blocked';
      statusEl.classList.remove('ok');
      statusEl.classList.add('err');
      hintEl.textContent = 'Microphone access denied. Please allow mic permission and try again.';
    }
  }

  // Respond to sliders
  micGainEl.addEventListener('input', () => setMicBoost(parseFloat(micGainEl.value)) );
  refVolEl.addEventListener('input', ()=>{ if (toneGain) toneGain.gain.value = refVolEl.value / 100; });

  function setMicBoost(mult){ if (preGain) preGain.gain.setValueAtTime(mult, audioCtx.currentTime); }

  // Tone helpers
  function toggleTone(i, toneBtn){
    if (!audioCtx) return; // needs context
    if (toneOscs[i]) {
      // stop
      try { toneOscs[i].stop(); } catch {}
      toneOscs[i].disconnect();
      toneOscs[i] = null;
      toneBtn.classList.remove('on');
      toneBtn.setAttribute('aria-pressed','false');
      return;
    }
    // start new osc for that string
    const osc = audioCtx.createOscillator();
    // richer than sine but not harsh: triangle through gentle lowpass
    const tri = osc; tri.type = 'triangle'; tri.frequency.value = STANDARD[i].freq;
    const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 3000; lp.Q.value = 0.0001;
    tri.connect(lp); lp.connect(toneGain);
    tri.start();
    toneOscs[i] = tri;
    toneBtn.classList.add('on');
    toneBtn.setAttribute('aria-pressed','true');
  }

  // Animation state
  let smoothFreq = 0; const SMOOTH_ALPHA = 0.25;

  function loop() {
    if (!running) return;
    analyser.getFloatTimeDomainData(dataBuf);
    const f = autoCorrelatePitch(dataBuf, audioCtx.sampleRate);
    if (f !== -1) {
      if (smoothFreq === 0) smoothFreq = f; else smoothFreq = smoothFreq + SMOOTH_ALPHA * (f - smoothFreq);
      updateUI(smoothFreq);
    } else {
      detectedNoteEl.textContent = '‚Äî';
      freqEl.textContent = '‚Äî Hz';
      centsEl.textContent = '‚Äî';
      setNeedle(0);
    }
    requestAnimationFrame(loop);
  }

  // Pitch detection (autocorrelation)
  function autoCorrelatePitch(buf, sampleRate) {
    // RMS gate
    let rms = 0; for (let i=0;i<buf.length;i++) { const v = buf[i]; rms += v*v; }
    rms = Math.sqrt(rms / buf.length);
    if (rms < 0.005) return -1; // more sensitive than before

    // Trim low-amplitude edges
    let start = 0, end = buf.length - 1;
    const threshold = 0.10; // was 0.2
    for (let i=0;i<buf.length;i++) { if (Math.abs(buf[i])>threshold) { start=i; break; } }
    for (let i=buf.length-1;i>=0;i--) { if (Math.abs(buf[i])>threshold) { end=i; break; } }
    const size = end - start;
    if (size < 32) return -1;

    const slice = buf.slice(start, end);

    const MAX_SAMPLES = Math.floor(sampleRate/82);
    const MIN_SAMPLES = Math.floor(sampleRate/1000);
    let bestOffset = -1, bestCorr = 0, lastCorr = 1;
    for (let offset = MIN_SAMPLES; offset < MAX_SAMPLES; offset++) {
      let corr = 0;
      for (let i=0; i<slice.length - offset; i++) corr += slice[i] * slice[i + offset];
      corr /= (slice.length - offset);
      if (corr > bestCorr && corr > 0.002) { bestCorr = corr; bestOffset = offset; }
      else if (bestCorr > 0.01 && corr < lastCorr) {
        const shift = parabolicInterp(slice, bestOffset);
        return sampleRate / (bestOffset + shift);
      }
      lastCorr = corr;
    }
    if (bestOffset > -1) return sampleRate / bestOffset;
    return -1;
  }

  function parabolicInterp(buf, offset) {
    const x0 = offset-1, x2 = offset+1;
    if (x0 < 0 || x2 >= buf.length) return 0;
    const s0 = buf[x0], s1 = buf[offset], s2 = buf[x2];
    const a = (s0 + s2 - 2*s1)/2; const b = (s2 - s0)/2; return a ? -b/(2*a) : 0;
  }

  function nearestStringIndex(freq) {
    let minIdx = 0, minDiff = Infinity;
    for (let i=0;i<STANDARD.length;i++) {
      const d = Math.abs(Math.log2(freq / STANDARD[i].freq));
      if (d < minDiff) { minDiff = d; minIdx = i; }
    }
    return minIdx;
  }

  function setNeedle(cents) {
    const clamped = Math.max(-50, Math.min(50, Math.round(cents)));
    const deg = (clamped / 50) * 45; // -45..+45
    needle.style.transform = `rotate(${deg}deg)`;
  }

  function updateUI(freq) {
    const idx = autoMode ? nearestStringIndex(freq) : manualIndex;
    const target = STANDARD[idx];

    updateActiveTile(idx);

    const cents = 1200 * Math.log2(freq / target.freq);
    const cDisp = Math.round(cents);

    freqEl.textContent = freq.toFixed(2) + ' Hz';
    centsEl.textContent = (cDisp>0? '+' : '') + cDisp;
    detectedNoteEl.textContent = `${target.name}`;

    setNeedle(cDisp);
    if (Math.abs(cDisp) <= 5) {
      hintEl.textContent = 'Perfect! In tune.';
      hintEl.style.color = 'var(--good)';
    } else if (cDisp < 0) {
      hintEl.textContent = 'Tune up (tighten)';
      hintEl.style.color = 'var(--warn)';
    } else {
      hintEl.textContent = 'Tune down (loosen)';
      hintEl.style.color = 'var(--warn)';
    }
  }

  // Simple input level scope
  const ctx = levelCanvas.getContext('2d');
  function drawLevel(){
    if (!running) return;
    requestAnimationFrame(drawLevel);
    analyser.getFloatTimeDomainData(dataBuf);
    const W = levelCanvas.width, H = levelCanvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#0b1119';
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#7ea7c7';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const step = Math.ceil(dataBuf.length / W);
    for (let x=0; x<W; x++) {
      const i = x*step;
      const v = (dataBuf[i] || 0);
      const y = H/2 + v * (H*0.45);
      if (x===0) ctx.moveTo(0,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // Accessibility: space to start mic; P unblock
  window.addEventListener('keydown', (e)=>{ if (e.code === 'Space') { e.preventDefault(); startAudio(); } });
  window.addEventListener('pointerdown', ()=>{ if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }, { once:false });

  // HTTPS hint
  if (location.protocol !== 'https:') { hintEl.textContent = 'Tip: Microphone only works on HTTPS or localhost.'; }

  // Init
  buildStringTiles();
  </script>
</body>
</html>
